{
  "nodes": {
    "1": {
      "node_id": "1",
      "node_kind": "Subsystem",
      "name": "Solar Power System",
      "description": "High-efficiency solar panels with tracking system.",
      "embodiment": {
        "principle": "Monocrystalline Solar Panels",
        "description": "High-efficiency panels with solar tracking for maximum energy capture.",
        "design_parameters": {
          "power_output": 300.0,
          "efficiency": 0.25
        },
        "cost_estimate": 500.0,
        "mass_estimate": 20.0,
        "status": "draft"
      },
      "physics_models": [
        {
          "name": "Solar Power Model",
          "equations": "P = A * \u03b7 * G",
          "python_code": "Okay, so I need to create a Python script for a Solar Power System node. The model is based on the equation P = A * \u03b7 * G, which makes sense because it's a common formula for calculating solar power output. The assumptions are steady-state and no temperature effects, so I don't have to worry about time-dependent changes or temperature impacting efficiency.\n\nFirst, I'll look at the provided code. There's a function called calculate_power that takes A, eta, and G as parameters and returns their product. That's a good start, but it's pretty basic. I need to expand this into a full script that meets all the requirements.\n\nThe user wants this to be a node in a larger Design-State Graph, so it needs to be self-contained and runnable. I should make sure to include all necessary imports and structure the code properly. They mentioned using standard libraries, NumPy, SciPy, and pytest, so I'll stick to those.\n\nI'll start by creating a module called solar_power_model. Inside this module, I'll define a class SolarPowerSystem. This class will encapsulate the functionality, making it easier to manage and extend if needed.\n\nIn the __init__ method, I'll set default values for area, efficiency, and irradiance. This way, users can create an instance without providing parameters immediately. I'll also include a method to calculate the power, which uses the formula provided.\n\nNext, I need to add command-line interface (CLI) functionality. Using argparse, I'll create a parse_args function that allows users to input area, efficiency, irradiance, and verbosity. The main function will handle parsing these arguments, setting up logging, and executing the calculation.\n\nLogging is important, so I'll configure the logging module based on the verbosity level. This helps in debugging and understanding the flow of the program.\n\nFor output, I'll create an outputs directory if it doesn't exist and save the results in both CSV and NumPy formats. This ensures that the data is portable and can be easily used by other nodes in the pipeline. Additionally, I'll include an optional quick-look plot using matplotlib to visualize the results.\n\nTesting is crucial, so I'll write a pytest function that checks the calculate_power method against known values. This ensures that the core functionality works as expected and catches any regressions.\n\nI also need to consider performance. Since the calculation is straightforward, vectorization isn't necessary here, but using NumPy for data handling ensures that the script can scale if needed in the future.\n\nFinally, I'll include a coupling stub function that shows how this node can interact with others. This function takes input data, runs the simulation, and returns the results, making it clear how data flows in and out of this node.\n\nPutting it all together, I'll structure the code with clear docstrings, separate functions for different responsibilities, and ensure that everything is self-contained. This makes the script easy to understand and run, fulfilling all the user's requirements.\n</think>\n\n```python\nimport argparse\nimport logging\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\n\ndef parse_args():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(description='Solar Power System Model')\n    parser.add_argument('--area', type=float, default=1.0,\n                       help='Solar panel area in m\u00b2')\n    parser.add_argument('--efficiency', type=float, default=0.2,\n                       help='Solar panel efficiency (0-1)')\n    parser.add_argument('--irradiance', type=float, default=1000.0,\n                       help='Solar irradiance in W/m\u00b2')\n    parser.add_argument('--verbosity', type=int, default=2,\n                       help='Verbosity level: 0=silent, 1=info, 2=debug')\n    return parser.parse_args()\n\nclass SolarPowerSystem:\n    \"\"\"Class representing a solar power system.\n    \n    Attributes:\n        area: float, Solar panel area in m\u00b2\n        efficiency: float, Solar panel efficiency (0-1)\n        irradiance: float, Solar irradiance in W/m\u00b2\n    \"\"\"\n    \n    def __init__(self, area=1.0, efficiency=0.2, irradiance=1000.0):\n        self.area = area\n        self.efficiency = efficiency\n        self.irradiance = irradiance\n        \n    def calculate_power(self):\n        \"\"\"Calculate solar power output.\n        \n        Returns:\n            float: Power output in Watts\n        \"\"\"\n        return self.area * self.efficiency * self.irradiance\n\ndef main():\n    \"\"\"Main function to execute solar power calculation.\"\"\"\n    args = parse_args()\n    \n    # Set logging level based on verbosity\n    if args.verbosity == 0:\n        logging.basicConfig(level=logging.ERROR)\n    elif args.verbosity == 1:\n        logging.basicConfig(level=logging.INFO)\n    else:\n        logging.basicConfig(level=logging.DEBUG)\n        \n    # Initialize solar power system\n    solar_system = SolarPowerSystem(\n        area=args.area,\n        efficiency=args.efficiency,\n        irradiance=args.irradiance\n    )\n    \n    # Calculate power\n    power = solar_system.calculate_power()\n    logging.info(f\"Calculated power output: {power} W\")\n    \n    # Save results to outputs directory\n    outputs_dir = \"outputs\"\n    os.makedirs(outputs_dir, exist_ok=True)\n    \n    # Save as CSV\n    np.savetxt(os.path.join(outputs_dir, \"power_output.csv\"), [power], header=\"Power (W)\")\n    \n    # Save as NumPy file\n    np.save(os.path.join(outputs_dir, \"power_output.npy\"), power)\n    \n    # Generate quick-look plot\n    plt.figure(figsize=(8, 6))\n    plt.title(\"Solar Power Output\")\n    plt.bar([\"Power\"], [power])\n    plt.xlabel(\"Metric\")\n    plt.ylabel(\"Value (W)\")\n    plt.savefig(os.path.join(outputs_dir, \"power_output.png\"))\n    plt.close()\n\ndef test_calculate_power():\n    \"\"\"Test the power calculation with known values.\"\"\"\n    # Test case 1: Standard conditions\n    area = 1.0  # m\u00b2\n    efficiency = 0.2  # 20%\n    irradiance = 1000.0  # W/m\u00b2\n    expected_power = area * efficiency * irradiance\n    \n    solar_system = SolarPowerSystem(area, efficiency, irradiance)\n    assert np.isclose(solar_system.calculate_power(), expected_power)\n    \n    # Test case 2: Double area\n    area = 2.0\n    expected_power = 2.0 * efficiency * irradiance\n    solar_system = SolarPowerSystem(area, efficiency, irradiance)\n    assert np.isclose(solar_system.calculate_power(), expected_power)\n    \n    # Test case 3: Double efficiency\n    efficiency = 0.4\n    expected_power = area * efficiency * irradiance\n    solar_system = SolarPowerSystem(area, efficiency, irradiance)\n    assert np.isclose(solar_system.calculate_power(), expected_power)\n\ndef coupling_stub(input_data):\n    \"\"\"Stub function for coupling with other system nodes.\n    \n    Args:\n        input_data: Dictionary containing input data\n        \n    Returns:\n        Dictionary containing output data\n    \"\"\"\n    # Example input data structure\n    if \"area\" in input_data and \"efficiency\" in input_data and \"irradiance\" in input_data:\n        solar_system = SolarPowerSystem(\n            area=input_data[\"area\"],\n            efficiency=input_data[\"efficiency\"],\n            irradiance=input_data[\"irradiance\"]\n        )\n        power = solar_system.calculate_power()\n        return {\"power_output\": power}\n    else:\n        raise ValueError(\"Missing required input parameters\")\n\nif __name__ == \"__main__\":\n    main()\n```",
          "coder_notes": "",
          "assumptions": [
            "steady-state",
            "no temperature effects"
          ],
          "status": "draft"
        }
      ],
      "linked_reqs": [
        "FR3",
        "FR4",
        "FR5"
      ],
      "verification_plan": "Test under varying irradiance conditions.",
      "maturity": "draft",
      "tags": [
        "Solar",
        "Power"
      ]
    },
    "2": {
      "node_id": "2",
      "node_kind": "Subsystem",
      "name": "Water Filtration System",
      "description": "Advanced filtration system with multiple stages.",
      "embodiment": {
        "principle": "Reverse Osmosis",
        "description": "Multi-stage filtration including pre-treatment and UV disinfection.",
        "design_parameters": {
          "flow_rate": 20.0,
          "efficiency": 0.99999
        },
        "cost_estimate": 300.0,
        "mass_estimate": 15.0,
        "status": "draft"
      },
      "physics_models": [
        {
          "name": "Filtration Model",
          "equations": "V = Q * t",
          "python_code": "Alright, so the user is asking for a Python script that models a water filtration system. They've provided a basic function that calculates volume as flow rate multiplied by time. My task is to expand this into a full, production-ready script that meets all the specified requirements.\n\nFirst, I need to understand the mission. The script should be a node in a larger system, handling physics-based simulation. It needs to be correct, runnable, high-fidelity, and self-contained. I can use libraries like NumPy, SciPy, and matplotlib, but keep dependencies minimal.\n\nLooking at the input, the node is named \"Water Filtration System\" with the model \"Filtration Model\". The governing equation is V = Q * t, which is straightforward. The assumptions are steady-state and constant flow rate, so the model doesn't need to handle transient flows or varying rates.\n\nThe existing code is a simple function. I need to build upon this. Let's think about the requirements:\n\n1. **Correctness & Fidelity**: The code must be syntactically correct and physically meaningful. I'll need to include units and perhaps more complex calculations if necessary, but since the equation is simple, ensuring correct units and handling edge cases is important.\n\n2. **Runnable**: The script should be executable after installing dependencies. I'll need to include a requirements.txt file listing necessary packages. Since the user mentioned using argparse and logging, I'll need to implement those.\n\n3. **Self-Documented**: I'll add docstrings to functions and modules. A README section at the end of the script will explain usage.\n\n4. **CLI**: Using argparse to expose parameters like flow rate and time. Also, adding a verbosity flag for logging.\n\n5. **Logging**: Implementing Python's logging module with different levels based on the verbosity flag.\n\n6. **Outputs**: Writing results to an outputs folder in formats like CSV or NumPy. Also, generating a quick-look plot using matplotlib.\n\n7. **Testing**: Including a pytest suite to verify the calculations against known values.\n\n8. **Coupling Stub**: Adding a function that can send or receive data from other nodes, even if it's just a placeholder for now.\n\n9. **Performance**: Since the calculations are simple, performance isn't a big issue here, but using efficient data structures is still good practice.\n\nNow, breaking down the steps:\n\n- **Command Line Interface**: I'll use argparse to get flow_rate, time, and verbosity. The script will parse these arguments when run.\n\n- **Logging Setup**: Configuring the logging module to output to both a file and the console, with the level determined by the verbosity argument.\n\n- **Volume Calculation**: Expanding the calculate_volume function to include error handling, such as negative values, and adding a docstring.\n\n- **Data Output**: Creating an outputs directory if it doesn't exist. Saving the results in both CSV and NumPy formats. Also, generating a simple plot to visualize the data over time.\n\n- **Testing**: Writing a test function that checks the volume calculation against expected values and runs with pytest.\n\n- **Coupling Function**: Adding a stub function that demonstrates how data would be passed to another node, even if it's not fully implemented yet.\n\nPotential issues to consider:\n\n- **Units Handling**: Ensuring that the inputs are in compatible units (e.g., m\u00b3/s for flow rate and seconds for time). The function currently doesn't enforce this, so it's up to the user to provide correct units.\n\n- **Edge Cases**: Handling cases where flow rate or time is zero or negative. The function now raises a ValueError if either is negative.\n\n- **Dependencies**: Making sure that all required libraries are included in the requirements.txt. Since the script uses NumPy, SciPy, matplotlib, and pytest, these need to be listed.\n\n- **Output Management**: Ensuring that the outputs directory is created and that files are written correctly without overwriting important data. Using datetime to create unique filenames could help, but for simplicity, the script currently doesn't do this.\n\n- **Logging Configuration**: Setting up logging to be flexible and useful for debugging. The script logs key events and errors, which can help in troubleshooting.\n\n- **Testing Coverage**: The test function is minimal but covers the basic functionality. More comprehensive tests could be added, but for now, it's sufficient.\n\nPutting it all together, the script starts by importing necessary modules, sets up logging, parses arguments, calculates the volume, saves the results, and generates a plot. The coupling function is a placeholder but shows where integration with other nodes would happen.\n\nFinally, the script includes a usage example and test command in the README section, making it easy for the user to run and verify the code.\n</think>\n\n```python\nimport argparse\nimport logging\nimport numpy as np\nimport os\nfrom scipy import constants\nimport matplotlib.pyplot as plt\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('filtration.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\ndef calculate_volume(flow_rate, time):\n    \"\"\"\n    Calculate the volume of filtered water based on flow rate and time.\n    \n    Args:\n        flow_rate (float): Flow rate in m\u00b3/s\n        time (float): Time in seconds\n        \n    Returns:\n        float: Volume in m\u00b3\n    \"\"\"\n    if flow_rate < 0 or time < 0:\n        raise ValueError(\"Flow rate and time must be non-negative\")\n        \n    return flow_rate * time\n\ndef save_results(volume, flow_rate, time, output_dir=\"outputs\"):\n    \"\"\"\n    Save results to specified output directory in multiple formats.\n    \"\"\"\n    # Create output directory if it doesn't exist\n    os.makedirs(output_dir, exist_ok=True)\n    \n    # Save as NumPy array\n    np.save(os.path.join(output_dir, \"volume.npy\"), volume)\n    \n    # Save as CSV\n    np.savetxt(os.path.join(output_dir, \"volume.csv\"), [volume], header=\"Volume (m\u00b3)\")\n    \n    logger.info(f\"Results saved to {output_dir}\")\n\ndef generate_plot(volume, flow_rate, time, output_dir=\"outputs\"):\n    \"\"\"\n    Generate a simple plot showing volume over time.\n    \"\"\"\n    time_array = np.linspace(0, time, 100)\n    volume_over_time = flow_rate * time_array\n    \n    plt.figure(figsize=(10, 6))\n    plt.plot(time_array, volume_over_time)\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Volume (m\u00b3)\")\n    plt.title(\"Volume of Filtered Water Over Time\")\n    plt.grid(True)\n    plt.savefig(os.path.join(output_dir, \"volume_plot.png\"))\n    plt.close()\n\n    logger.info(\"Plot generated successfully\")\n\ndef coupling_stub(input_data):\n    \"\"\"\n    Stub function for coupling with other system components.\n    \"\"\"\n    # This would typically send/receive data to/from other nodes\n    logger.info(\"Coupling stub executed\")\n    return input_data\n\ndef main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description='Water Filtration System Model')\n    parser.add_argument('--flow_rate', type=float, default=1.0, help='Flow rate in m\u00b3/s')\n    parser.add_argument('--time', type=float, default=3600, help='Time in seconds')\n    parser.add_argument('--verbosity', type=int, default=2, \n                       help='Verbosity level: 0=DEBUG, 1=INFO, 2=WARNING, 3=ERROR, 4=CRITICAL')\n    args = parser.parse_args()\n    \n    # Set logging level based on verbosity\n    logger.setLevel([logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL][args.verbosity])\n    \n    # Calculate volume\n    volume = calculate_volume(args.flow_rate, args.time)\n    logger.info(f\"Calculated volume: {volume} m\u00b3\")\n    \n    # Save results\n    save_results(volume, args.flow_rate, args.time)\n    \n    # Generate plot\n    generate_plot(volume, args.flow_rate, args.time)\n    \n    # Call coupling stub\n    coupling_stub(volume)\n\nif __name__ == \"__main__\":\n    main()\n\n# Requirements:\n# pip install numpy scipy matplotlib\n\n# Usage:\n# python water_filtration.py --flow_rate 2.0 --time 7200 --verbosity 1\n\n# Test function\ndef test_calculate_volume():\n    assert np.isclose(calculate_volume(2.0, 3600), 7200.0)\n    assert np.isclose(calculate_volume(0.5, 1800), 900.0)\n    try:\n        calculate_volume(-1.0, 100)\n        assert False, \"Should raise ValueError for negative flow rate\"\n    except ValueError:\n        pass\n\ndef test_save_and_load_results():\n    volume = 100.0\n    save_results(volume, 1.0, 100)\n    loaded_volume = np.load(\"outputs/volume.npy\")\n    assert np.isclose(loaded_volume, volume)\n    os.remove(\"outputs/volume.npy\")\n    os.remove(\"outputs/volume.csv\")\n\ndef test_coupling_stub():\n    input_data = 100.0\n    output_data = coupling_stub(input_data)\n    assert output_data == input_data\n\n# Run tests with:\n# pytest water_filtration.py -v\n```",
          "coder_notes": "",
          "assumptions": [
            "steady-state",
            "constant flow rate"
          ],
          "status": "draft"
        }
      ],
      "linked_reqs": [
        "FR1",
        "FR2"
      ],
      "verification_plan": "Test water quality after filtration.",
      "maturity": "draft",
      "tags": [
        "Filtration",
        "Water"
      ]
    },
    "3": {
      "node_id": "3",
      "node_kind": "Subsystem",
      "name": "Energy Storage System",
      "description": "High-capacity lithium-ion batteries for extended operation.",
      "embodiment": {
        "principle": "Lithium-Ion Battery",
        "description": "High-capacity, long-life batteries with advanced management system.",
        "design_parameters": {
          "capacity": 300.0,
          "voltage": 24.0
        },
        "cost_estimate": 400.0,
        "mass_estimate": 30.0,
        "status": "draft"
      },
      "physics_models": [
        {
          "name": "Battery Model",
          "equations": "E = C * V",
          "python_code": "Okay, so I need to create a Python script for a battery model node. The user provided a simple function that calculates energy as capacity multiplied by voltage. But they want it to be a high-fidelity node in a larger engineering system, so I need to expand on that.\n\nFirst, I should think about the requirements. The node needs to be correct, runnable, and self-contained. It should use standard libraries and maybe some like NumPy or SciPy. Also, it needs to have a CLI, logging, output to a file, and some testing.\n\nThe governing equation is E = C * V, which is straightforward. But since it's a battery model, maybe I should include more realistic features. Oh, the assumptions are steady-state and no losses, so I don't need to handle transients or inefficiencies right now.\n\nI should structure the script with a main function, maybe a class for the battery. That way, it's organized and can be easily extended. The class can have methods to calculate energy, store results, and maybe include some logging.\n\nFor the CLI, I'll use argparse. I'll add parameters for capacity, voltage, and maybe output options. Logging is important, so I'll include a --verbose flag to set the logging level.\n\nOutput needs to go into an ./outputs directory. I'll make sure the script creates this if it doesn't exist. I'll save the energy value in a JSON file for easy reading and maybe a CSV for data analysis.\n\nTesting is crucial. I'll write a pytest function that checks if the energy calculation is correct. It should compare the computed value with the expected one, ensuring the function works as intended.\n\nI also need a coupling stub. This function can take data from other nodes, like maybe getting the voltage from a power source node. For now, it can just return the energy, but it should be clear where it can be integrated.\n\nThinking about performance, since the calculation is simple, it's not a big issue here. But if this were part of a larger system, using vectorized operations with NumPy would be better for handling multiple batteries or time steps.\n\nPutting it all together, I'll start by importing necessary modules. Then, set up logging and the argument parser. The Battery class will handle the calculations and data storage. The main function will parse the arguments, create the Battery instance, run the calculation, and handle output.\n\nI should also include a README section at the end with usage examples. That way, users know how to run the script and what options are available.\n\nFinally, I'll write the test function using pytest. It will instantiate the Battery class with test values and assert that the energy is correct. This ensures that any changes don't break the core functionality.\n\nI think that covers all the requirements. Now, I'll structure the code step by step, making sure each part is modular and well-documented.\n</think>\n\n```python\nimport argparse\nimport json\nimport logging\nimport os\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nimport numpy as np\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass BatteryConfig:\n    capacity: float  # Capacity in Ah (Ampere-hours)\n    voltage: float   # Voltage in V (Volts)\n    output_path: str  # Path to output directory\n\nclass BatteryModel:\n    def __init__(self, config: BatteryConfig):\n        self.config = config\n        \n    def calculate_energy(self) -> float:\n        \"\"\"Calculates battery energy in Wh (Watt-hours)\"\"\"\n        energy = self.config.capacity * self.config.voltage\n        logger.info(f\"Calculated energy: {energy} Wh\")\n        return energy\n        \n    def store_results(self, energy: float) -> None:\n        \"\"\"Stores results in JSON and CSV format\"\"\"\n        results = {\n            \"energy\": energy,\n            \"capacity\": self.config.capacity,\n            \"voltage\": self.config.voltage\n        }\n        \n        os.makedirs(self.config.output_path, exist_ok=True)\n        \n        # Store as JSON\n        with open(os.path.join(self.config.output_path, \"battery_energy.json\"), \"w\") as f:\n            json.dump(results, f, indent=2)\n            logger.info(f\"Results saved to {f.name}\")\n            \n        # Store as CSV\n        np.savetxt(\n            os.path.join(self.config.output_path, \"battery_energy.csv\"),\n            [energy],\n            header=\"Energy (Wh)\",\n            delimiter=\",\"\n        )\n        logger.info(f\"CSV results saved to {os.path.join(self.config.output_path, 'battery_energy.csv')}\")\n        \ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"Battery Energy Calculator\")\n    parser.add_argument(\"--capacity\", type=float, default=10.0, help=\"Battery capacity in Ah\")\n    parser.add_argument(\"--voltage\", type=float, default=12.0, help=\"Battery voltage in V\")\n    parser.add_argument(\"--output\", type=str, default=\"./outputs\", help=\"Output directory\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"Enable verbose logging\")\n    return parser.parse_args()\n\ndef main() -> None:\n    args = parse_args()\n    \n    # Set up logging\n    logging.basicConfig(\n        level=logging.DEBUG if args.verbose else logging.INFO,\n        format=\"[%(asctime)s] %(levelname)s: %(message)s\"\n    )\n    \n    # Create configuration\n    config = BatteryConfig(\n        capacity=args.capacity,\n        voltage=args.voltage,\n        output_path=args.output\n    )\n    \n    # Initialize and run battery model\n    battery = BatteryModel(config)\n    energy = battery.calculate_energy()\n    battery.store_results(energy)\n    \n    logger.info(\"Battery energy calculation completed successfully\")\n\ndef coupling_stub() -> Optional[float]:\n    \"\"\"\n    Stub function for coupling with other system components.\n    Returns calculated energy if available, otherwise None.\n    \"\"\"\n    try:\n        # Example usage in a coupled system\n        args = parse_args()\n        config = BatteryConfig(\n            capacity=args.capacity,\n            voltage=args.voltage,\n            output_path=args.output\n        )\n        battery = BatteryModel(config)\n        energy = battery.calculate_energy()\n        return energy\n    except Exception as e:\n        logger.error(f\"Error in coupling stub: {str(e)}\")\n        return None\n\nif __name__ == \"__main__\":\n    main()\n\ndef test_calculate_energy():\n    config = BatteryConfig(\n        capacity=10.0,\n        voltage=12.0,\n        output_path=\"./outputs\"\n    )\n    battery = BatteryModel(config)\n    energy = battery.calculate_energy()\n    assert np.isclose(energy, 120.0), \"Energy calculation incorrect\"\n```",
          "coder_notes": "",
          "assumptions": [
            "steady-state",
            "no losses"
          ],
          "status": "draft"
        }
      ],
      "linked_reqs": [
        "FR5"
      ],
      "verification_plan": "Test energy storage capacity.",
      "maturity": "draft",
      "tags": [
        "Battery",
        "Storage"
      ]
    }
  },
  "edges": [
    [
      "1",
      "2"
    ],
    [
      "1",
      "3"
    ],
    [
      "3",
      "2"
    ]
  ]
}