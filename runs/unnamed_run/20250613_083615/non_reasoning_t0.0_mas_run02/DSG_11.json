{
  "nodes": {
    "1": {
      "node_id": "1",
      "node_kind": "Component",
      "name": "Solar Panel",
      "description": "Converts sunlight into electrical energy",
      "embodiment": {
        "principle": "Photovoltaic",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 1500.0,
        "mass_estimate": 60.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "Electrical Power Generation",
          "equations": "P = \u03b7 \u22c5 A \u22c5 G",
          "coding_directives": "Python",
          "python_code": "## Reasoning Process\n\nThe problem involves modeling the electrical power generation of a solar panel. The given equation is P = \u03b7 \u22c5 A \u22c5 G, where:\n\n* P is the electrical power generated\n* \u03b7 is the efficiency of the solar panel\n* A is the area of the solar panel\n* G is the solar irradiance\n\nThe assumption is that the solar irradiance is constant.\n\nTo create a high-fidelity physics-based simulation, we will:\n\n1. Define the parameters of the solar panel, including its efficiency and area.\n2. Use the given equation to calculate the electrical power generated.\n3. Expose key parameters via command-line arguments.\n4. Write results to an output file in a portable format.\n5. Include a minimal test suite to verify the correctness of the simulation.\n\n## Python Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\n\ndef calculate_power(eta, A, G):\n    \"\"\"\n    Calculate the electrical power generated by the solar panel.\n\n    Parameters:\n    eta (float): Efficiency of the solar panel\n    A (float): Area of the solar panel\n    G (float): Solar irradiance\n\n    Returns:\n    float: Electrical power generated\n    \"\"\"\n    return eta * A * G\n\ndef main():\n    # Define command-line arguments\n    parser = argparse.ArgumentParser(description='Solar Panel Power Generation Simulation')\n    parser.add_argument('--eta', type=float, default=0.4, help='Efficiency of the solar panel')\n    parser.add_argument('--A', type=float, default=25, help='Area of the solar panel')\n    parser.add_argument('--G', type=float, default=1200, help='Solar irradiance')\n    parser.add_argument('--verbosity', type=int, default=0, help='Verbosity level')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity > 0 else logging.WARNING)\n\n    # Calculate power\n    power = calculate_power(args.eta, args.A, args.G)\n\n    # Write results to output file\n    output_dir = './outputs'\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    np.save(os.path.join(output_dir, 'power.npy'), np.array([power]))\n\n    # Print results\n    logging.info(f'Electrical power generated: {power} W')\n\ndef test_calculate_power():\n    # Test case: eta = 0.4, A = 25, G = 1200\n    eta = 0.4\n    A = 25\n    G = 1200\n    expected_power = 12000\n    assert np.isclose(calculate_power(eta, A, G), expected_power)\n\nif __name__ == '__main__':\n    main()\n```\n\n## Usage\n\nTo run the simulation, save the code to a file (e.g., `solar_panel.py`) and execute it using Python:\n```bash\npython solar_panel.py\n```\nYou can modify the command-line arguments to change the parameters of the simulation. For example:\n```bash\npython solar_panel.py --eta 0.5 --A 30 --G 1000\n```\nThe results will be written to an output file in the `./outputs` directory.\n\n## Testing\n\nTo run the test suite, use the `pytest` command:\n```bash\npytest solar_panel.py\n```\nThis will verify that the `calculate_power` function is working correctly.",
          "coder_notes": "",
          "assumptions": [
            "Constant solar irradiance"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-01",
        "SR-02"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Renewable Energy",
        "Solar Power"
      ]
    },
    "2": {
      "node_id": "2",
      "node_kind": "Component",
      "name": "Water Tank",
      "description": "Stores raw water for filtration",
      "embodiment": {
        "principle": "Stainless Steel Container",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 1000.0,
        "mass_estimate": 70.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "Water Storage",
          "equations": "V = \u03c0 \u22c5 r^2 \u22c5 h",
          "coding_directives": "Python",
          "python_code": "## Reasoning Process\n\nThe problem involves creating a high-fidelity physics-based simulation node for a water tank, specifically focusing on water storage. The given equation `V = \u03c0 \u22c5 r^2 \u22c5 h` represents the volume of water in the tank, where `r` is the radius of the tank and `h` is the height of the water level.\n\nGiven the assumption of a constant water level, we can use this equation to calculate the volume of water in the tank. However, to make the node more versatile and useful in a larger pipeline, we should consider the following:\n\n1.  **Input Parameters**: Expose key parameters such as the radius and height of the water level via command-line arguments.\n2.  **Output Format**: Write the calculated volume to a file in a portable format, such as CSV or NumPy.\n3.  **Logging and Verbosity**: Implement logging with a verbosity flag to control the level of output.\n4.  **Testing and Verification**: Include a minimal test suite to verify the correctness of the calculation.\n5.  **Coupling Stub**: Provide a function that can be used to send or receive data from other nodes in the pipeline.\n\n## Python Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport pytest\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef calculate_water_volume(radius, height):\n    \"\"\"\n    Calculate the volume of water in the tank.\n\n    Parameters:\n    radius (float): The radius of the tank.\n    height (float): The height of the water level.\n\n    Returns:\n    float: The volume of water in the tank.\n    \"\"\"\n    volume = np.pi * (radius ** 2) * height\n    return volume\n\ndef save_output(volume, output_file):\n    \"\"\"\n    Save the calculated volume to a file.\n\n    Parameters:\n    volume (float): The calculated volume.\n    output_file (str): The path to the output file.\n    \"\"\"\n    np.save(output_file, volume)\n    logging.info(f\"Output saved to {output_file}\")\n\ndef coupling_stub(volume):\n    \"\"\"\n    A stub function for sending or receiving data from other nodes.\n\n    Parameters:\n    volume (float): The calculated volume.\n    \"\"\"\n    # TO DO: Implement the logic for sending or receiving data\n    logging.info(f\"Volume: {volume}\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='Water Tank Simulation')\n    parser.add_argument('--radius', type=float, default=1.8, help='The radius of the tank')\n    parser.add_argument('--height', type=float, default=18, help='The height of the water level')\n    parser.add_argument('--output_file', type=str, default='output.npy', help='The path to the output file')\n    parser.add_argument('--verbosity', type=int, default=1, help='The level of verbosity')\n    args = parser.parse_args()\n\n    # Set the logging level based on the verbosity flag\n    if args.verbosity == 0:\n        logging.basicConfig(level=logging.ERROR)\n    elif args.verbosity == 1:\n        logging.basicConfig(level=logging.INFO)\n    elif args.verbosity == 2:\n        logging.basicConfig(level=logging.DEBUG)\n\n    volume = calculate_water_volume(args.radius, args.height)\n    logging.info(f\"Calculated volume: {volume}\")\n\n    # Create the output directory if it does not exist\n    output_dir = os.path.dirname(args.output_file)\n    if output_dir and not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    save_output(volume, args.output_file)\n    coupling_stub(volume)\n\ndef test_calculate_water_volume():\n    radius = 1.8\n    height = 18\n    expected_volume = np.pi * (radius ** 2) * height\n    calculated_volume = calculate_water_volume(radius, height)\n    assert np.isclose(expected_volume, calculated_volume)\n\nif __name__ == '__main__':\n    main()\n    # Run the test suite\n    pytest.main([__file__])\n```\n\n## Usage\n\nTo run the script, save it to a file (e.g., `water_tank.py`) and execute it using Python:\n\n```bash\npython water_tank.py --radius 1.8 --height 18 --output_file output.npy --verbosity 1\n```\n\nThis will calculate the volume of water in the tank with the given radius and height, save the output to a file named `output.npy`, and log the calculated volume with an info level of verbosity.\n\nTo run the test suite, use the following command:\n\n```bash\npytest water_tank.py\n```",
          "coder_notes": "",
          "assumptions": [
            "Constant water level"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-03",
        "SR-04"
      ],
      "verification_plan": "Inspection of the system design and components",
      "maturity": "High",
      "tags": [
        "Water Storage",
        "Stainless Steel Container"
      ]
    },
    "3": {
      "node_id": "3",
      "node_kind": "Component",
      "name": "Filtration Unit",
      "description": "Removes contaminants from water",
      "embodiment": {
        "principle": "Reverse Osmosis",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 1800.0,
        "mass_estimate": 80.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "Contaminant Removal",
          "equations": "C = (1 - e^(-k \u22c5 t)) \u22c5 C0",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nThe given equation `C = (1 - e^(-k \u22c5 t)) \u22c5 C0` represents the contaminant removal model, where:\n- `C` is the final contaminant concentration\n- `k` is the removal rate constant\n- `t` is the time\n- `C0` is the initial contaminant concentration\n\nThe provided Python code calculates the final contaminant concentration `C` using the given equation with specific values for `k`, `t`, and `C0`. However, to create a high-fidelity physics/data-generation node, we need to:\n1. Expose key parameters via command-line arguments.\n2. Implement logging for verbosity control.\n3. Write results to an output folder in a portable format.\n4. Include a minimal test suite for verification.\n\n### Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport matplotlib.pyplot as plt\n\ndef calculate_contaminant_concentration(k, t, C0):\n    \"\"\"\n    Calculate the final contaminant concentration using the contaminant removal model.\n\n    Args:\n    - k (float): Removal rate constant\n    - t (float): Time\n    - C0 (float): Initial contaminant concentration\n\n    Returns:\n    - C (float): Final contaminant concentration\n    \"\"\"\n    C = (1 - np.exp(-k * t)) * C0\n    return C\n\ndef main():\n    # Parse command-line arguments\n    parser = argparse.ArgumentParser(description='Contaminant Removal Model')\n    parser.add_argument('--k', type=float, default=0.3, help='Removal rate constant')\n    parser.add_argument('--t', type=float, default=20, help='Time')\n    parser.add_argument('--C0', type=float, default=180, help='Initial contaminant concentration')\n    parser.add_argument('--verbosity', type=int, default=1, help='Logging verbosity')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity > 0 else logging.WARNING)\n\n    # Calculate contaminant concentration\n    C = calculate_contaminant_concentration(args.k, args.t, args.C0)\n    logging.info(f'Final contaminant concentration: {C}')\n\n    # Create output folder if it doesn't exist\n    output_folder = './outputs'\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n\n    # Write results to output folder\n    np.save(os.path.join(output_folder, 'contaminant_concentration.npy'), C)\n\n    # Generate a quick-look plot\n    t_values = np.linspace(0, args.t, 100)\n    C_values = (1 - np.exp(-args.k * t_values)) * args.C0\n    plt.plot(t_values, C_values)\n    plt.xlabel('Time')\n    plt.ylabel('Contaminant Concentration')\n    plt.title('Contaminant Removal Model')\n    plt.savefig(os.path.join(output_folder, 'contaminant_removal_plot.png'))\n\n    # Coupling stub: Send/receive data to/from other nodes\n    def send_data(data):\n        # TO DO: Implement data sending logic\n        pass\n\n    def receive_data():\n        # TO DO: Implement data receiving logic\n        pass\n\n    # Send and receive data\n    send_data(C)\n    received_data = receive_data()\n\ndef test_contaminant_removal_model():\n    # Test the contaminant removal model with known values\n    k = 0.3\n    t = 20\n    C0 = 180\n    expected_C = (1 - np.exp(-k * t)) * C0\n    calculated_C = calculate_contaminant_concentration(k, t, C0)\n    assert np.isclose(expected_C, calculated_C)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Usage\n\nTo run the script, save it as `contaminant_removal.py` and execute it using Python:\n```bash\npython contaminant_removal.py\n```\nYou can modify the command-line arguments to change the removal rate constant, time, and initial contaminant concentration. For example:\n```bash\npython contaminant_removal.py --k 0.5 --t 30 --C0 200\n```\nThe script will write the results to the `./outputs` folder in a portable format (NumPy) and generate a quick-look plot. The coupling stub functions `send_data` and `receive_data` are currently placeholders and need to be implemented to send and receive data to/from other nodes.",
          "coder_notes": "",
          "assumptions": [
            "Constant flow rate"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-05",
        "SR-06"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Water Filtration",
        "Reverse Osmosis"
      ]
    },
    "4": {
      "node_id": "4",
      "node_kind": "Component",
      "name": "Pump",
      "description": "Transfers water from tank to filtration unit",
      "embodiment": {
        "principle": "Centrifugal Pump",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 700.0,
        "mass_estimate": 20.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "Water Transfer",
          "equations": "Q = (P \u22c5 \u03b7) / (\u03c1 \u22c5 g)",
          "coding_directives": "Python",
          "python_code": "## Reasoning Process\n\nThe given equation `Q = (P \u22c5 \u03b7) / (\u03c1 \u22c5 g)` represents the relationship between the volumetric flow rate `Q` of a pump, its power `P`, efficiency `\u03b7`, the density of the fluid `\u03c1`, and the acceleration due to gravity `g`. \n\nGiven the assumptions of constant pump speed, we can use this equation to calculate the volumetric flow rate of the pump. \n\nThe provided Python code calculates the volumetric flow rate `Q` using the given equation, with `P = 2000`, `\u03b7 = 0.95`, `\u03c1 = 1200`, and `g = 9.81`. \n\nHowever, to make this code more robust and user-friendly, we can add the following features:\n\n*   Use `argparse` to expose key parameters via the command line interface.\n*   Use Python's `logging` module to control the verbosity of the output.\n*   Write the results to an `./outputs` folder in a portable format (e.g., CSV).\n*   Include a minimal pytest suite to verify the calculation.\n\n## Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport csv\nimport pytest\n\ndef calculate_flow_rate(power, efficiency, density, gravity=9.81):\n    \"\"\"\n    Calculate the volumetric flow rate of a pump.\n\n    Parameters:\n    power (float): The power of the pump in Watts.\n    efficiency (float): The efficiency of the pump.\n    density (float): The density of the fluid in kg/m^3.\n    gravity (float, optional): The acceleration due to gravity in m/s^2. Defaults to 9.81.\n\n    Returns:\n    float: The volumetric flow rate of the pump in m^3/s.\n    \"\"\"\n    flow_rate = (power * efficiency) / (density * gravity)\n    return flow_rate\n\ndef main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description='Calculate the volumetric flow rate of a pump.')\n    parser.add_argument('--power', type=float, default=2000, help='The power of the pump in Watts.')\n    parser.add_argument('--efficiency', type=float, default=0.95, help='The efficiency of the pump.')\n    parser.add_argument('--density', type=float, default=1200, help='The density of the fluid in kg/m^3.')\n    parser.add_argument('--verbosity', type=int, default=0, help='The level of verbosity.')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity > 0 else logging.WARNING)\n\n    # Calculate the flow rate\n    flow_rate = calculate_flow_rate(args.power, args.efficiency, args.density)\n\n    # Write the result to a CSV file\n    output_dir = './outputs'\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    with open(os.path.join(output_dir, 'flow_rate.csv'), 'w', newline='') as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow(['Flow Rate (m^3/s)'])\n        writer.writerow([flow_rate])\n\n    # Log the result\n    logging.info(f'The volumetric flow rate of the pump is {flow_rate:.2f} m^3/s.')\n\ndef test_calculate_flow_rate():\n    # Test the calculate_flow_rate function\n    power = 2000\n    efficiency = 0.95\n    density = 1200\n    expected_flow_rate = (power * efficiency) / (density * 9.81)\n    assert np.isclose(calculate_flow_rate(power, efficiency, density), expected_flow_rate)\n\nif __name__ == '__main__':\n    main()\n```\n\n## Usage\n\nTo run the script, save it to a file (e.g., `pump.py`) and execute it using Python:\n\n```bash\npython pump.py\n```\n\nYou can adjust the parameters using the command line arguments:\n\n```bash\npython pump.py --power 2500 --efficiency 0.9 --density 1000 --verbosity 1\n```\n\nThe result will be written to a CSV file in the `./outputs` directory.\n\nTo run the test, use pytest:\n\n```bash\npytest pump.py\n```",
          "coder_notes": "",
          "assumptions": [
            "Constant pump speed"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-07",
        "SR-08"
      ],
      "verification_plan": "Inspection of the system design and components",
      "maturity": "High",
      "tags": [
        "Water Transfer",
        "Centrifugal Pump"
      ]
    },
    "5": {
      "node_id": "5",
      "node_kind": "Component",
      "name": "Control Unit",
      "description": "Regulates system operation and monitors water quality",
      "embodiment": {
        "principle": "Microcontroller",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 1200.0,
        "mass_estimate": 15.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "System Control",
          "equations": "T = (1 / f) \u22c5 (V / I)",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nThe given equation `T = (1 / f) * (V / I)` represents the relationship between the time period `T`, frequency `f`, voltage `V`, and current `I`. The assumption of a constant system load implies that the voltage and current are constant.\n\nTo create a high-fidelity physics/data-generation node, we will:\n\n1. Define a function to calculate the time period `T` based on the given equation.\n2. Use NumPy for numerical computations and provide a simple command-line interface (CLI) using `argparse` to expose key parameters.\n3. Implement logging using Python's `logging` module with a `--verbosity` flag.\n4. Write results to an `./outputs` folder in a portable format (NumPy) and include an optional quick-look plot.\n5. Include a minimal pytest suite to verify the calculation.\n\n### Python Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport matplotlib.pyplot as plt\nimport pytest\n\ndef calculate_time_period(frequency, voltage, current):\n    \"\"\"\n    Calculate the time period T based on the given equation.\n\n    Parameters:\n    frequency (float): The frequency f.\n    voltage (float): The voltage V.\n    current (float): The current I.\n\n    Returns:\n    float: The time period T.\n    \"\"\"\n    return (1 / frequency) * (voltage / current)\n\ndef main():\n    # Parse command-line arguments\n    parser = argparse.ArgumentParser(description='System Control Node')\n    parser.add_argument('--frequency', type=float, default=2.0, help='The frequency f')\n    parser.add_argument('--voltage', type=float, default=20.0, help='The voltage V')\n    parser.add_argument('--current', type=float, default=4.0, help='The current I')\n    parser.add_argument('--verbosity', type=int, default=1, help='The verbosity level')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity == 1 else logging.DEBUG)\n    logger = logging.getLogger(__name__)\n\n    # Calculate the time period\n    time_period = calculate_time_period(args.frequency, args.voltage, args.current)\n    logger.info(f'Time period: {time_period}')\n\n    # Write results to file\n    output_dir = './outputs'\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    np.save(os.path.join(output_dir, 'time_period.npy'), time_period)\n\n    # Optional quick-look plot\n    plt.plot([args.frequency], [time_period], 'bo')\n    plt.xlabel('Frequency')\n    plt.ylabel('Time Period')\n    plt.title('Time Period vs Frequency')\n    plt.savefig(os.path.join(output_dir, 'time_period_plot.png'))\n\ndef coupling_stub(time_period):\n    \"\"\"\n    Stub function to send/receive data if this node were composited with others.\n\n    Parameters:\n    time_period (float): The calculated time period.\n    \"\"\"\n    # TO DO: Implement data sending/receiving logic\n    pass\n\ndef test_calculate_time_period():\n    \"\"\"\n    Test the calculate_time_period function.\n    \"\"\"\n    frequency = 2.0\n    voltage = 20.0\n    current = 4.0\n    expected_time_period = (1 / frequency) * (voltage / current)\n    assert np.isclose(calculate_time_period(frequency, voltage, current), expected_time_period)\n\nif __name__ == '__main__':\n    main()\n    # Run pytest suite\n    pytest.main([__file__])\n```\n\n### Usage\n\nTo run the script, save it to a file (e.g., `system_control.py`) and execute it using Python:\n```bash\npython system_control.py\n```\nThis will calculate the time period using the default values and write the result to a file in the `./outputs` directory. You can modify the command-line arguments to change the input values.\n\nTo run the pytest suite, use the following command:\n```bash\npytest system_control.py\n```\nThis will verify that the `calculate_time_period` function produces the expected result for a given set of input values.",
          "coder_notes": "",
          "assumptions": [
            "Constant system load"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-09",
        "SR-10"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "System Control",
        "Microcontroller"
      ]
    }
  },
  "edges": [
    [
      "1",
      "2"
    ],
    [
      "2",
      "3"
    ],
    [
      "3",
      "4"
    ],
    [
      "4",
      "5"
    ],
    [
      "5",
      "1"
    ]
  ],
  "workflow_complete": false
}