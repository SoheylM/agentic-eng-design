{
  "nodes": {
    "1": {
      "node_id": "1",
      "node_kind": "Component",
      "name": "Solar Panel",
      "description": "Converts sunlight into electrical energy",
      "embodiment": {
        "principle": "Photovoltaic",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 1000.0,
        "mass_estimate": 50.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "Electrical Power Generation",
          "equations": "P = \u03b7 \u22c5 A \u22c5 G",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nThe problem involves modeling the electrical power generation of a solar panel. The given equation is P = \u03b7 \u22c5 A \u22c5 G, where:\n\n* P is the electrical power generated by the solar panel\n* \u03b7 is the efficiency of the solar panel\n* A is the area of the solar panel\n* G is the solar irradiance\n\nThe assumption is that the solar irradiance is constant.\n\nTo create a high-fidelity physics-based simulation, we will:\n\n1. Define the parameters of the solar panel, including its efficiency and area.\n2. Use the given equation to calculate the electrical power generated by the solar panel.\n3. Expose key parameters via `argparse` to allow for easy modification of the simulation.\n4. Use Python's `logging` module to log important events and errors.\n5. Write the results to an `./outputs` folder in a portable format (e.g., CSV).\n6. Include a minimal pytest suite to verify the correctness of the simulation.\n\n### Python Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport csv\n\ndef calculate_power(eta, A, G):\n    \"\"\"\n    Calculate the electrical power generated by the solar panel.\n\n    Parameters:\n    eta (float): Efficiency of the solar panel\n    A (float): Area of the solar panel\n    G (float): Solar irradiance\n\n    Returns:\n    float: Electrical power generated by the solar panel\n    \"\"\"\n    return eta * A * G\n\ndef main():\n    # Define the parser\n    parser = argparse.ArgumentParser(description='Solar Panel Power Generation Simulation')\n    parser.add_argument('--eta', type=float, default=0.3, help='Efficiency of the solar panel')\n    parser.add_argument('--A', type=float, default=20, help='Area of the solar panel')\n    parser.add_argument('--G', type=float, default=1000, help='Solar irradiance')\n    parser.add_argument('--verbosity', type=int, default=0, help='Verbosity level')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity > 0 else logging.WARNING)\n\n    # Calculate the power\n    power = calculate_power(args.eta, args.A, args.G)\n\n    # Create the outputs folder if it doesn't exist\n    outputs_folder = './outputs'\n    if not os.path.exists(outputs_folder):\n        os.makedirs(outputs_folder)\n\n    # Write the results to a CSV file\n    with open(os.path.join(outputs_folder, 'power_generation.csv'), 'w', newline='') as csvfile:\n        fieldnames = ['eta', 'A', 'G', 'power']\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n        writer.writeheader()\n        writer.writerow({'eta': args.eta, 'A': args.A, 'G': args.G, 'power': power})\n\n    # Log the results\n    logging.info(f'Power generated: {power} W')\n\n    # Send/receive data stub\n    def send_data(data):\n        # TO DO: implement data sending logic\n        pass\n\n    def receive_data():\n        # TO DO: implement data receiving logic\n        pass\n\n    # Send the results\n    send_data(power)\n\ndef test_calculate_power():\n    # Test the calculate_power function\n    eta = 0.3\n    A = 20\n    G = 1000\n    expected_power = 6000\n    assert np.isclose(calculate_power(eta, A, G), expected_power)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Usage\n\nTo run the simulation, save the code to a file (e.g., `solar_panel.py`) and run it using Python:\n```bash\npython solar_panel.py\n```\nYou can modify the parameters of the simulation using the `--eta`, `--A`, and `--G` flags. For example:\n```bash\npython solar_panel.py --eta 0.4 --A 30 --G 1200\n```\nThe results will be written to a CSV file in the `./outputs` folder.\n\n### Testing\n\nTo run the tests, save the code to a file (e.g., `solar_panel.py`) and run the tests using pytest:\n```bash\npytest solar_panel.py\n```\nThe tests will verify the correctness of the `calculate_power` function.",
          "coder_notes": "",
          "assumptions": [
            "Constant solar irradiance"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-01",
        "SR-03"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Renewable Energy",
        "Solar Power"
      ]
    },
    "2": {
      "node_id": "2",
      "node_kind": "Component",
      "name": "Water Tank",
      "description": "Stores raw water for filtration",
      "embodiment": {
        "principle": "Stainless Steel Container",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 800.0,
        "mass_estimate": 60.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "Water Storage",
          "equations": "V = \u03c0 \u22c5 r^2 \u22c5 h",
          "coding_directives": "Python",
          "python_code": "## Reasoning Process\n\nThe problem involves creating a high-fidelity physics-based simulation node for a water tank, specifically focusing on water storage. The given equation `V = \u03c0 \u22c5 r^2 \u22c5 h` represents the volume of water in the tank, where `r` is the radius of the tank and `h` is the height of the water level.\n\nGiven the assumption of a constant water level, we can use this equation to calculate the volume of water in the tank. However, to make the node more versatile and useful in a larger pipeline, we should consider the following:\n\n1.  **Input Parameters**: Expose key parameters such as the radius and height of the water level via command-line arguments.\n2.  **Output Format**: Write the calculated volume to a file in a portable format, such as CSV or NumPy.\n3.  **Logging and Verbosity**: Implement logging with a verbosity flag to control the level of output.\n4.  **Testing and Verification**: Include a minimal test suite to verify the correctness of the calculation.\n5.  **Coupling Stub**: Provide a function that can be used to send or receive data from other nodes in the pipeline.\n\n## Python Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport pytest\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\ndef calculate_water_volume(radius, height):\n    \"\"\"\n    Calculate the volume of water in the tank.\n\n    Parameters:\n    radius (float): The radius of the tank.\n    height (float): The height of the water level.\n\n    Returns:\n    float: The volume of water in the tank.\n    \"\"\"\n    volume = np.pi * (radius ** 2) * height\n    return volume\n\ndef save_volume_to_file(volume, output_file):\n    \"\"\"\n    Save the calculated volume to a file.\n\n    Parameters:\n    volume (float): The calculated volume.\n    output_file (str): The path to the output file.\n    \"\"\"\n    np.save(output_file, volume)\n    logger.info(f\"Volume saved to {output_file}\")\n\ndef send_data_to_other_node(volume):\n    \"\"\"\n    Stub function to send data to other nodes in the pipeline.\n\n    Parameters:\n    volume (float): The calculated volume.\n    \"\"\"\n    # TO DO: Implement data sending logic here\n    logger.info(f\"Sending volume {volume} to other node\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='Water Tank Node')\n    parser.add_argument('--radius', type=float, default=1.5, help='The radius of the tank')\n    parser.add_argument('--height', type=float, default=15, help='The height of the water level')\n    parser.add_argument('--output_file', type=str, default='volume.npy', help='The path to the output file')\n    parser.add_argument('--verbosity', type=int, default=1, help='The level of verbosity')\n    args = parser.parse_args()\n\n    if args.verbosity == 0:\n        logger.setLevel(logging.ERROR)\n    elif args.verbosity == 1:\n        logger.setLevel(logging.INFO)\n    elif args.verbosity == 2:\n        logger.setLevel(logging.DEBUG)\n\n    volume = calculate_water_volume(args.radius, args.height)\n    logger.info(f\"Calculated volume: {volume}\")\n\n    output_dir = './outputs'\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    output_file = os.path.join(output_dir, args.output_file)\n    save_volume_to_file(volume, output_file)\n\n    send_data_to_other_node(volume)\n\ndef test_calculate_water_volume():\n    radius = 1.5\n    height = 15\n    expected_volume = np.pi * (radius ** 2) * height\n    calculated_volume = calculate_water_volume(radius, height)\n    assert np.isclose(calculated_volume, expected_volume)\n\nif __name__ == '__main__':\n    main()\n    pytest.main([__file__])\n```\n\n## Usage\n\nTo run the script, save it to a file (e.g., `water_tank.py`) and execute it using Python:\n\n```bash\npython water_tank.py\n```\n\nYou can adjust the input parameters using command-line arguments:\n\n```bash\npython water_tank.py --radius 2.0 --height 20\n```\n\nThe calculated volume will be saved to a file named `volume.npy` in the `./outputs` directory. You can change the output file name using the `--output_file` argument.\n\nTo test the script, run the following command:\n\n```bash\npytest water_tank.py\n```",
          "coder_notes": "",
          "assumptions": [
            "Constant water level"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-01",
        "SR-02"
      ],
      "verification_plan": "Inspection of the system design and components",
      "maturity": "High",
      "tags": [
        "Water Storage",
        "Stainless Steel Container"
      ]
    },
    "3": {
      "node_id": "3",
      "node_kind": "Component",
      "name": "Filtration Unit",
      "description": "Removes contaminants from water",
      "embodiment": {
        "principle": "Reverse Osmosis",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 1200.0,
        "mass_estimate": 70.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "Contaminant Removal",
          "equations": "C = (1 - e^(-k \u22c5 t)) \u22c5 C0",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nThe given equation `C = (1 - e^(-k \u22c5 t)) \u22c5 C0` represents the contaminant removal model, where:\n- `C` is the concentration of contaminants after time `t`\n- `k` is the removal rate constant\n- `t` is the time\n- `C0` is the initial concentration of contaminants\n\nThe provided Python code calculates the concentration `C` after 15 time units with a removal rate constant `k = 0.2` and an initial concentration `C0 = 150`.\n\nTo create a high-fidelity physics/data-generation node, we will:\n1. Define a function to calculate the contaminant concentration based on the given equation.\n2. Use `argparse` to expose key parameters via the command line interface (CLI).\n3. Implement logging using Python's `logging` module with a `--verbosity` flag.\n4. Write results to an `./outputs` folder in a portable format (NumPy) and include an optional quick-look plot.\n5. Create a minimal pytest suite to verify the calculation.\n\n### Python Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport matplotlib.pyplot as plt\nimport pytest\n\ndef calculate_concentration(k, t, C0):\n    \"\"\"\n    Calculate the contaminant concentration after time t.\n\n    Args:\n    k (float): Removal rate constant\n    t (float): Time\n    C0 (float): Initial concentration of contaminants\n\n    Returns:\n    float: Concentration of contaminants after time t\n    \"\"\"\n    return (1 - np.exp(-k * t)) * C0\n\ndef main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description='Contaminant Removal Model')\n    parser.add_argument('--k', type=float, default=0.2, help='Removal rate constant')\n    parser.add_argument('--t', type=float, default=15, help='Time')\n    parser.add_argument('--C0', type=float, default=150, help='Initial concentration of contaminants')\n    parser.add_argument('--verbosity', type=int, default=1, help='Logging verbosity')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity == 1 else logging.DEBUG)\n    logger = logging.getLogger(__name__)\n\n    # Calculate concentration\n    concentration = calculate_concentration(args.k, args.t, args.C0)\n    logger.info(f'Concentration after {args.t} time units: {concentration}')\n\n    # Create output directory if it doesn't exist\n    output_dir = './outputs'\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    # Save results to file\n    np.save(os.path.join(output_dir, 'concentration.npy'), concentration)\n\n    # Optional quick-look plot\n    plt.plot([0, args.t], [args.C0, concentration])\n    plt.xlabel('Time')\n    plt.ylabel('Concentration')\n    plt.title('Contaminant Removal')\n    plt.savefig(os.path.join(output_dir, 'concentration_plot.png'))\n\ndef coupling_stub(k, t, C0):\n    \"\"\"\n    Stub function for sending/receiving data if this node were composited with others.\n\n    Args:\n    k (float): Removal rate constant\n    t (float): Time\n    C0 (float): Initial concentration of contaminants\n\n    Returns:\n    float: Concentration of contaminants after time t\n    \"\"\"\n    return calculate_concentration(k, t, C0)\n\n# Testing\ndef test_calculate_concentration():\n    k = 0.2\n    t = 15\n    C0 = 150\n    concentration = calculate_concentration(k, t, C0)\n    assert np.isclose(concentration, 150 * (1 - np.exp(-0.2 * 15)))\n\nif __name__ == '__main__':\n    main()\n    test_calculate_concentration()\n```\n\n### Usage\n\nTo run the script, save it to a file (e.g., `filtration_unit.py`) and execute it using Python:\n```bash\npython filtration_unit.py\n```\nYou can modify the command line arguments to change the removal rate constant, time, and initial concentration:\n```bash\npython filtration_unit.py --k 0.1 --t 10 --C0 100\n```\nThe results will be saved to the `./outputs` directory in a NumPy file (`concentration.npy`) and an optional quick-look plot (`concentration_plot.png`).",
          "coder_notes": "",
          "assumptions": [
            "Constant flow rate"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-02",
        "SR-04"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Water Filtration",
        "Reverse Osmosis"
      ]
    },
    "4": {
      "node_id": "4",
      "node_kind": "Component",
      "name": "Pump",
      "description": "Transfers water from tank to filtration unit",
      "embodiment": {
        "principle": "Centrifugal Pump",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 500.0,
        "mass_estimate": 15.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "Water Transfer",
          "equations": "Q = (P \u22c5 \u03b7) / (\u03c1 \u22c5 g)",
          "coding_directives": "Python",
          "python_code": "## Reasoning Process\n\nThe given equation `Q = (P \u22c5 \u03b7) / (\u03c1 \u22c5 g)` represents the relationship between the volumetric flow rate `Q` of a pump, its power `P`, efficiency `\u03b7`, the density of the fluid `\u03c1`, and the acceleration due to gravity `g`. The assumptions provided include a constant pump speed.\n\nTo create a high-fidelity physics node for the water transfer model, we will:\n\n1. Define the model parameters and their units.\n2. Implement the equation to calculate the volumetric flow rate `Q`.\n3. Use `argparse` to expose key parameters via the command line interface (CLI).\n4. Utilize Python's `logging` module to control the verbosity of the output.\n5. Write the results to an `./outputs` folder in a portable format (e.g., CSV).\n6. Include a minimal pytest suite to verify the calculation against an analytic case.\n\n## Python Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport csv\nimport pytest\n\ndef calculate_flow_rate(power, efficiency, density, gravity=9.81):\n    \"\"\"\n    Calculate the volumetric flow rate of a pump.\n\n    Parameters:\n    power (float): The power of the pump in Watts.\n    efficiency (float): The efficiency of the pump as a decimal value.\n    density (float): The density of the fluid in kg/m\u00b3.\n    gravity (float, optional): The acceleration due to gravity in m/s\u00b2. Defaults to 9.81.\n\n    Returns:\n    float: The volumetric flow rate of the pump in m\u00b3/s.\n    \"\"\"\n    flow_rate = (power * efficiency) / (density * gravity)\n    return flow_rate\n\ndef main():\n    # Define the CLI arguments\n    parser = argparse.ArgumentParser(description='Water Transfer Model')\n    parser.add_argument('--power', type=float, default=1500, help='The power of the pump in Watts')\n    parser.add_argument('--efficiency', type=float, default=0.9, help='The efficiency of the pump as a decimal value')\n    parser.add_argument('--density', type=float, default=1000, help='The density of the fluid in kg/m\u00b3')\n    parser.add_argument('--verbosity', type=int, default=1, help='The level of verbosity for the output')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity > 0 else logging.WARNING)\n\n    # Calculate the flow rate\n    flow_rate = calculate_flow_rate(args.power, args.efficiency, args.density)\n\n    # Create the outputs folder if it doesn't exist\n    outputs_folder = './outputs'\n    if not os.path.exists(outputs_folder):\n        os.makedirs(outputs_folder)\n\n    # Write the results to a CSV file\n    with open(os.path.join(outputs_folder, 'flow_rate.csv'), 'w', newline='') as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow(['Flow Rate (m\u00b3/s)'])\n        writer.writerow([flow_rate])\n\n    # Log the result\n    logging.info(f'Flow rate: {flow_rate:.4f} m\u00b3/s')\n\ndef test_calculate_flow_rate():\n    # Test the calculate_flow_rate function\n    power = 1500\n    efficiency = 0.9\n    density = 1000\n    expected_flow_rate = (power * efficiency) / (density * 9.81)\n    assert np.isclose(calculate_flow_rate(power, efficiency, density), expected_flow_rate)\n\nif __name__ == '__main__':\n    main()\n```\n\n## Usage\n\nTo run the script, save it to a file (e.g., `water_transfer.py`) and execute it using Python:\n```bash\npython water_transfer.py\n```\nYou can modify the CLI arguments to change the input parameters. For example:\n```bash\npython water_transfer.py --power 2000 --efficiency 0.8 --density 1200\n```\nThe results will be written to a CSV file in the `./outputs` folder.\n\n## Testing\n\nTo run the pytest suite, save the script to a file (e.g., `water_transfer.py`) and execute the following command:\n```bash\npytest water_transfer.py\n```\nThis will verify that the `calculate_flow_rate` function produces the expected result for a given set of input parameters.",
          "coder_notes": "",
          "assumptions": [
            "Constant pump speed"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-01",
        "SR-03"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Water Transfer",
        "Centrifugal Pump"
      ]
    },
    "5": {
      "node_id": "5",
      "node_kind": "Component",
      "name": "Control Unit",
      "description": "Regulates system operation and monitors water quality",
      "embodiment": {
        "principle": "Microcontroller",
        "description": "",
        "design_parameters": {},
        "cost_estimate": 800.0,
        "mass_estimate": 10.0,
        "status": "Validated"
      },
      "physics_models": [
        {
          "name": "System Control",
          "equations": "T = (1 / f) \u22c5 (V / I)",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nThe given equation `T = (1 / f) * (V / I)` represents the relationship between the time constant `T`, frequency `f`, voltage `V`, and current `I` in a system. The assumption of a constant system load implies that the frequency `f` and the ratio of voltage to current `V/I` are constant.\n\nTo create a high-fidelity physics/data-generation node, we will:\n\n1. Define a function to calculate the time constant `T` based on the given equation.\n2. Use NumPy for numerical computations and provide a simple command-line interface (CLI) using `argparse` to expose key parameters.\n3. Implement logging using Python's `logging` module with a `--verbosity` flag.\n4. Write results to an `./outputs` folder in a portable format (NumPy) and include an optional quick-look plot.\n5. Include a minimal pytest suite to verify the calculation.\n\n### Python Code\n\n```python\nimport numpy as np\nimport argparse\nimport logging\nimport os\nimport matplotlib.pyplot as plt\nimport pytest\n\ndef calculate_time_constant(frequency, voltage, current):\n    \"\"\"\n    Calculate the time constant T based on the given equation.\n\n    Parameters:\n    frequency (float): The frequency of the system.\n    voltage (float): The voltage of the system.\n    current (float): The current of the system.\n\n    Returns:\n    float: The time constant T.\n    \"\"\"\n    return (1 / frequency) * (voltage / current)\n\ndef main():\n    # Parse command-line arguments\n    parser = argparse.ArgumentParser(description='System Control Node')\n    parser.add_argument('--frequency', type=float, default=1.5, help='Frequency of the system')\n    parser.add_argument('--voltage', type=float, default=15, help='Voltage of the system')\n    parser.add_argument('--current', type=float, default=3, help='Current of the system')\n    parser.add_argument('--verbosity', type=int, default=0, help='Logging verbosity')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity > 0 else logging.WARNING)\n\n    # Calculate time constant\n    time_constant = calculate_time_constant(args.frequency, args.voltage, args.current)\n    logging.info(f'Time constant: {time_constant}')\n\n    # Write results to file\n    output_dir = './outputs'\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    np.save(os.path.join(output_dir, 'time_constant.npy'), time_constant)\n\n    # Optional quick-look plot\n    if args.verbosity > 1:\n        plt.plot([time_constant])\n        plt.xlabel('Time Constant')\n        plt.ylabel('Value')\n        plt.title('Time Constant Plot')\n        plt.savefig(os.path.join(output_dir, 'time_constant_plot.png'))\n\ndef test_calculate_time_constant():\n    # Test the calculate_time_constant function\n    frequency = 1.5\n    voltage = 15\n    current = 3\n    expected_time_constant = (1 / frequency) * (voltage / current)\n    assert np.isclose(calculate_time_constant(frequency, voltage, current), expected_time_constant)\n\nif __name__ == '__main__':\n    main()\n    # Run pytest suite\n    pytest.main([__file__])\n```\n\n### Usage\n\nTo run the script, save it to a file (e.g., `system_control.py`) and execute it using Python:\n```bash\npython system_control.py\n```\nYou can modify the command-line arguments to change the frequency, voltage, and current values. For example:\n```bash\npython system_control.py --frequency 2.0 --voltage 20 --current 4\n```\nThe script will write the calculated time constant to a file named `time_constant.npy` in the `./outputs` directory. If you enable the quick-look plot by setting the `--verbosity` flag to 2 or higher, the script will also generate a plot named `time_constant_plot.png` in the same directory.",
          "coder_notes": "",
          "assumptions": [
            "Constant system load"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-04",
        "SR-05"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "System Control",
        "Microcontroller"
      ]
    }
  },
  "edges": [
    [
      "1",
      "5"
    ],
    [
      "2",
      "4"
    ],
    [
      "4",
      "3"
    ],
    [
      "3",
      "5"
    ]
  ],
  "workflow_complete": false
}