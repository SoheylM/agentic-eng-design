{
  "nodes": {
    "SP-2": {
      "node_id": "SP-2",
      "node_kind": "Component",
      "name": "Solar Panel",
      "description": "Converts sunlight into electrical energy",
      "embodiment": {
        "principle": "Bifacial Solar Panel",
        "description": "High-efficiency solar panel",
        "design_parameters": {},
        "cost_estimate": 500.0,
        "mass_estimate": 40.0,
        "status": "draft"
      },
      "physics_models": [
        {
          "name": "Electrical Power Generation",
          "equations": "P = \u03b7 \u22c5 A \u22c5 G",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nTo create a high-fidelity physics-based simulation node for a solar panel's electrical power generation, we will follow the guidelines provided. The governing equation for the power generated by a solar panel is given by `P = \u03b7 \u22c5 A \u22c5 G`, where `P` is the power generated, `\u03b7` is the efficiency of the solar panel, `A` is the area of the solar panel, and `G` is the solar irradiance.\n\nGiven the assumption of constant solar irradiance, we will focus on creating a Python script that calculates the power generated by the solar panel using the provided equation. We will also include features such as command-line interface (CLI) arguments, logging, and output writing to an `./outputs` folder.\n\n### Python Code\n\n```python\nimport argparse\nimport logging\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\ndef calculate_power(eta, A, G):\n    \"\"\"\n    Calculate the power generated by a solar panel.\n\n    Parameters:\n    eta (float): Efficiency of the solar panel\n    A (float): Area of the solar panel\n    G (float): Solar irradiance\n\n    Returns:\n    float: Power generated by the solar panel\n    \"\"\"\n    return eta * A * G\n\ndef main():\n    # Set up logging\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n    parser = argparse.ArgumentParser(description='Solar Panel Power Generation')\n    parser.add_argument('--eta', type=float, default=0.2, help='Efficiency of the solar panel')\n    parser.add_argument('--A', type=float, default=10.0, help='Area of the solar panel')\n    parser.add_argument('--G', type=float, default=1000.0, help='Solar irradiance')\n    parser.add_argument('--verbosity', type=int, default=1, help='Logging verbosity')\n    args = parser.parse_args()\n\n    # Set logging level based on verbosity\n    if args.verbosity == 0:\n        logging.basicConfig(level=logging.ERROR)\n    elif args.verbosity == 1:\n        logging.basicConfig(level=logging.INFO)\n    elif args.verbosity == 2:\n        logging.basicConfig(level=logging.DEBUG)\n\n    # Calculate power\n    power = calculate_power(args.eta, args.A, args.G)\n    logging.info(f'Power generated: {power} W')\n\n    # Create outputs folder if it doesn't exist\n    if not os.path.exists('./outputs'):\n        os.makedirs('./outputs')\n\n    # Write results to file\n    np.save('./outputs/power.npy', power)\n    logging.info('Results written to ./outputs/power.npy')\n\n    # Create a quick-look plot\n    plt.plot([0, 1], [0, power])\n    plt.xlabel('Time (s)')\n    plt.ylabel('Power (W)')\n    plt.title('Solar Panel Power Generation')\n    plt.savefig('./outputs/power_plot.png')\n    logging.info('Quick-look plot saved to ./outputs/power_plot.png')\n\n    # Coupling stub: send data to next node\n    def send_data(data):\n        # TO DO: implement data sending to next node\n        logging.info('Sending data to next node...')\n        return data\n    send_data(power)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Testing / Verification\n\nTo test the `calculate_power` function, we can use the following pytest code:\n\n```python\nimport pytest\nimport numpy as np\n\ndef test_calculate_power():\n    eta = 0.2\n    A = 10.0\n    G = 1000.0\n    power = calculate_power(eta, A, G)\n    assert np.isclose(power, 2000.0)\n```\n\n### README / Usage\n\nTo run the script, save it to a file (e.g., `solar_panel.py`) and execute it using `python solar_panel.py`. You can modify the command-line arguments using the `--eta`, `--A`, and `--G` flags. For example:\n\n```bash\npython solar_panel.py --eta 0.3 --A 20.0 --G 500.0\n```\n\nThis will calculate the power generated by a solar panel with an efficiency of 0.3, an area of 20.0 m\u00b2, and a solar irradiance of 500.0 W/m\u00b2. The results will be written to `./outputs/power.npy` and a quick-look plot will be saved to `./outputs/power_plot.png`.",
          "coder_notes": "",
          "assumptions": [
            "Constant solar irradiance"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-01",
        "SR-03"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Renewable Energy",
        "Solar Power"
      ]
    },
    "WT-2": {
      "node_id": "WT-2",
      "node_kind": "Component",
      "name": "Water Tank",
      "description": "Stores raw water for filtration",
      "embodiment": {
        "principle": "Stainless Steel Container",
        "description": "Durable and corrosion-resistant",
        "design_parameters": {},
        "cost_estimate": 600.0,
        "mass_estimate": 80.0,
        "status": "draft"
      },
      "physics_models": [
        {
          "name": "Water Storage",
          "equations": "V = \u03c0 \u22c5 r^2 \u22c5 h",
          "coding_directives": "Python",
          "python_code": "## Reasoning Process\n\nTo create a high-fidelity physics node for a water tank, we will start by defining the governing equation for the volume of water in the tank. The equation provided, V = \u03c0 \u22c5 r^2 \u22c5 h, represents the volume of a cylinder, where r is the radius of the tank and h is the height of the water.\n\nGiven the assumption of a constant water level, we can use this equation to calculate the volume of water in the tank at any given time.\n\nWe will create a Python class to represent the water tank, with methods to calculate the volume of water and to simulate the filling or draining of the tank.\n\nWe will use the `argparse` library to expose key parameters via the command line interface, and the `logging` library to handle logging.\n\nWe will also include a minimal pytest suite to verify the correctness of the volume calculation.\n\n## Code\n\n```python\nimport argparse\nimport logging\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pytest\nimport os\n\nclass WaterTank:\n    \"\"\"\n    A class to represent a water tank.\n\n    Attributes:\n    r (float): The radius of the tank.\n    h (float): The height of the water in the tank.\n    \"\"\"\n\n    def __init__(self, r, h):\n        \"\"\"\n        Initialize the water tank with the given radius and water height.\n\n        Args:\n        r (float): The radius of the tank.\n        h (float): The height of the water in the tank.\n        \"\"\"\n        self.r = r\n        self.h = h\n\n    def calculate_volume(self):\n        \"\"\"\n        Calculate the volume of water in the tank.\n\n        Returns:\n        float: The volume of water in the tank.\n        \"\"\"\n        return np.pi * self.r**2 * self.h\n\n    def simulate_filling(self, dh):\n        \"\"\"\n        Simulate the filling of the tank by a given amount.\n\n        Args:\n        dh (float): The amount to fill the tank by.\n        \"\"\"\n        self.h += dh\n\n    def simulate_draining(self, dh):\n        \"\"\"\n        Simulate the draining of the tank by a given amount.\n\n        Args:\n        dh (float): The amount to drain the tank by.\n\n        Raises:\n        ValueError: If the amount to drain is greater than the current water height.\n        \"\"\"\n        if dh > self.h:\n            raise ValueError(\"Cannot drain more water than is currently in the tank\")\n        self.h -= dh\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Water tank simulator\")\n    parser.add_argument(\"--radius\", type=float, default=1.0, help=\"The radius of the tank\")\n    parser.add_argument(\"--height\", type=float, default=1.0, help=\"The initial height of the water in the tank\")\n    parser.add_argument(\"--fill\", type=float, default=0.0, help=\"The amount to fill the tank by\")\n    parser.add_argument(\"--drain\", type=float, default=0.0, help=\"The amount to drain the tank by\")\n    parser.add_argument(\"--verbosity\", type=int, default=0, help=\"The level of logging verbosity\")\n    args = parser.parse_args()\n\n    logging.basicConfig(level=logging.INFO if args.verbosity > 0 else logging.WARNING)\n\n    tank = WaterTank(args.radius, args.height)\n\n    if args.fill > 0:\n        tank.simulate_filling(args.fill)\n    if args.drain > 0:\n        tank.simulate_draining(args.drain)\n\n    volume = tank.calculate_volume()\n    logging.info(f\"The volume of water in the tank is {volume:.2f} cubic units\")\n\n    # Create a quick-look plot\n    plt.plot([0, tank.h], [0, tank.r], label=\"Water level\")\n    plt.xlabel(\"Height\")\n    plt.ylabel(\"Radius\")\n    plt.title(\"Water Tank\")\n    plt.legend()\n    plt.savefig(\"water_tank_plot.png\")\n\n    # Write the results to a file\n    with open(\"water_tank_results.txt\", \"w\") as f:\n        f.write(f\"Volume: {volume:.2f} cubic units\\n\")\n        f.write(f\"Water height: {tank.h:.2f} units\\n\")\n\ndef test_calculate_volume():\n    tank = WaterTank(1.0, 1.0)\n    assert np.isclose(tank.calculate_volume(), np.pi)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Usage\n\nTo run the script, save it to a file (e.g. `water_tank.py`) and run it from the command line:\n```bash\npython water_tank.py --radius 1.0 --height 1.0 --fill 0.5 --drain 0.2 --verbosity 1\n```\nThis will simulate a water tank with a radius of 1.0 units and an initial water height of 1.0 units, fill it by 0.5 units, drain it by 0.2 units, and print the final volume of water in the tank. The `--verbosity` flag controls the level of logging output.\n\nThe script will also create a quick-look plot of the water tank and write the results to a file named `water_tank_results.txt`.",
          "coder_notes": "",
          "assumptions": [
            "Constant water level"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-01",
        "SR-02"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Water Storage",
        "Stainless Steel Container"
      ]
    },
    "FU-2": {
      "node_id": "FU-2",
      "node_kind": "Component",
      "name": "Filtration Unit",
      "description": "Removes contaminants from water",
      "embodiment": {
        "principle": "Reverse Osmosis",
        "description": "High-efficiency filtration",
        "design_parameters": {},
        "cost_estimate": 700.0,
        "mass_estimate": 50.0,
        "status": "draft"
      },
      "physics_models": [
        {
          "name": "Contaminant Removal",
          "equations": "C = (1 - e^(-k \u22c5 t)) \u22c5 C0",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nThe given equation `C = (1 - e^(-k \u22c5 t)) \u22c5 C0` represents the concentration of contaminants in a filtration unit over time, where `k` is the removal rate constant, `t` is time, and `C0` is the initial concentration. \n\nTo create a high-fidelity physics/data-generation node, we will:\n\n1. Implement the `calculate_concentration` function.\n2. Add input validation and error handling.\n3. Create a command-line interface (CLI) using `argparse` to expose key parameters.\n4. Use Python's `logging` module to control verbosity.\n5. Write results to an `./outputs` folder in a portable format (e.g., CSV).\n6. Include a minimal pytest suite to verify the implementation.\n\n### Python Code\n\n```python\nimport argparse\nimport csv\nimport logging\nimport numpy as np\nimport os\nimport pytest\n\ndef calculate_concentration(k, t, C0):\n    \"\"\"\n    Calculate the concentration of contaminants in a filtration unit over time.\n\n    Parameters:\n    k (float): Removal rate constant\n    t (float or numpy array): Time\n    C0 (float): Initial concentration\n\n    Returns:\n    float or numpy array: Concentration at time t\n    \"\"\"\n    return (1 - np.exp(-k * t)) * C0\n\ndef main():\n    # Set up logging\n    logging.basicConfig(level=logging.INFO)\n    parser = argparse.ArgumentParser(description='Filtration Unit Model')\n    parser.add_argument('--k', type=float, default=0.1, help='Removal rate constant')\n    parser.add_argument('--t', type=float, default=10, help='Time')\n    parser.add_argument('--C0', type=float, default=100, help='Initial concentration')\n    parser.add_argument('--verbosity', type=int, default=1, help='Logging verbosity')\n    args = parser.parse_args()\n\n    # Set logging level\n    logging.getLogger().setLevel(logging.getLevelName(args.verbosity * 10))\n\n    # Calculate concentration\n    concentration = calculate_concentration(args.k, args.t, args.C0)\n\n    # Write results to CSV file\n    output_dir = './outputs'\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    with open(os.path.join(output_dir, 'concentration.csv'), 'w', newline='') as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow(['Time', 'Concentration'])\n        if isinstance(concentration, np.ndarray):\n            for t, c in zip(args.t, concentration):\n                writer.writerow([t, c])\n        else:\n            writer.writerow([args.t, concentration])\n\n    # Log result\n    logging.info(f'Concentration at time {args.t}: {concentration}')\n\ndef coupling_stub(k, t, C0):\n    \"\"\"\n    Stub function for sending/receiving data to/from other nodes.\n\n    Parameters:\n    k (float): Removal rate constant\n    t (float or numpy array): Time\n    C0 (float): Initial concentration\n\n    Returns:\n    float or numpy array: Concentration at time t\n    \"\"\"\n    # TO DO: Implement data sending/receiving logic\n    return calculate_concentration(k, t, C0)\n\n# Pytest suite\ndef test_calculate_concentration():\n    k = 0.1\n    t = 10\n    C0 = 100\n    concentration = calculate_concentration(k, t, C0)\n    assert concentration >= 0 and concentration <= C0\n\nif __name__ == '__main__':\n    main()\n```\n\n### Usage\n\nTo run the script, save it to a file (e.g., `filtration_unit.py`) and execute it using Python:\n```bash\npython filtration_unit.py --k 0.1 --t 10 --C0 100 --verbosity 1\n```\nThis will calculate the concentration at time `t=10` with removal rate constant `k=0.1` and initial concentration `C0=100`, and write the result to a CSV file in the `./outputs` directory.\n\nTo run the pytest suite, use the following command:\n```bash\npytest filtration_unit.py\n```",
          "coder_notes": "",
          "assumptions": [
            "Constant flow rate"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-02",
        "SR-04"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Water Filtration",
        "Reverse Osmosis"
      ]
    },
    "P-2": {
      "node_id": "P-2",
      "node_kind": "Component",
      "name": "Pump",
      "description": "Transfers water from tank to filtration unit",
      "embodiment": {
        "principle": "Centrifugal Pump",
        "description": "High-efficiency pump",
        "design_parameters": {},
        "cost_estimate": 400.0,
        "mass_estimate": 30.0,
        "status": "draft"
      },
      "physics_models": [
        {
          "name": "Water Transfer",
          "equations": "Q = (P \u22c5 \u03b7) / (\u03c1 \u22c5 g)",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nThe given equation `Q = (P \u22c5 \u03b7) / (\u03c1 \u22c5 g)` represents the flow rate of a pump, where:\n- `Q` is the flow rate (m\u00b3/s)\n- `P` is the power of the pump (W)\n- `\u03b7` is the efficiency of the pump (unitless)\n- `\u03c1` is the density of the fluid (kg/m\u00b3)\n- `g` is the acceleration due to gravity (m/s\u00b2)\n\nTo create a high-fidelity physics node, we will:\n1. Define a function to calculate the flow rate based on the given equation.\n2. Use `argparse` to expose key parameters via the command line interface.\n3. Implement logging using Python's `logging` module.\n4. Write results to an `./outputs` folder in a portable format (NumPy).\n5. Include a minimal pytest suite to verify the calculation.\n\n### Python Code\n\n```python\nimport argparse\nimport logging\nimport numpy as np\nimport os\nimport pytest\n\ndef calculate_flow_rate(P, eta, rho, g):\n    \"\"\"\n    Calculate the flow rate of a pump.\n\n    Parameters:\n    P (float): Power of the pump (W)\n    eta (float): Efficiency of the pump (unitless)\n    rho (float): Density of the fluid (kg/m\u00b3)\n    g (float): Acceleration due to gravity (m/s\u00b2)\n\n    Returns:\n    float: Flow rate of the pump (m\u00b3/s)\n    \"\"\"\n    return (P * eta) / (rho * g)\n\ndef main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description='Pump flow rate calculator')\n    parser.add_argument('--power', type=float, default=1000, help='Power of the pump (W)')\n    parser.add_argument('--efficiency', type=float, default=0.8, help='Efficiency of the pump (unitless)')\n    parser.add_argument('--density', type=float, default=1000, help='Density of the fluid (kg/m\u00b3)')\n    parser.add_argument('--gravity', type=float, default=9.81, help='Acceleration due to gravity (m/s\u00b2)')\n    parser.add_argument('--verbosity', type=int, default=1, help='Logging verbosity')\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity == 1 else logging.DEBUG)\n    logger = logging.getLogger(__name__)\n\n    # Calculate flow rate\n    flow_rate = calculate_flow_rate(args.power, args.efficiency, args.density, args.gravity)\n    logger.info(f'Flow rate: {flow_rate:.2f} m\u00b3/s')\n\n    # Write results to file\n    output_dir = './outputs'\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    np.save(os.path.join(output_dir, 'flow_rate.npy'), flow_rate)\n\ndef coupling_stub(flow_rate):\n    \"\"\"\n    Stub function for sending/receiving data to/from other nodes.\n\n    Parameters:\n    flow_rate (float): Flow rate of the pump (m\u00b3/s)\n    \"\"\"\n    # TO DO: Implement data sending/receiving logic\n    pass\n\n# Pytest suite\ndef test_calculate_flow_rate():\n    assert np.isclose(calculate_flow_rate(1000, 0.8, 1000, 9.81), 0.08163, atol=1e-5)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Usage\n\nTo run the script, save it to a file (e.g., `pump.py`) and execute it using Python:\n```bash\npython pump.py\n```\nYou can modify the command line arguments to change the input values. For example:\n```bash\npython pump.py --power 500 --efficiency 0.9 --density 1200 --gravity 9.8\n```\nThe script will calculate the flow rate and write the result to a file named `flow_rate.npy` in the `./outputs` directory. You can also run the pytest suite using:\n```bash\npytest pump.py\n```",
          "coder_notes": "",
          "assumptions": [
            "Constant pump speed"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-01",
        "SR-03"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "Water Transfer",
        "Centrifugal Pump"
      ]
    },
    "CU-2": {
      "node_id": "CU-2",
      "node_kind": "Component",
      "name": "Control Unit",
      "description": "Regulates system operation and monitors water quality",
      "embodiment": {
        "principle": "Microcontroller",
        "description": "High-efficiency control unit",
        "design_parameters": {},
        "cost_estimate": 300.0,
        "mass_estimate": 20.0,
        "status": "draft"
      },
      "physics_models": [
        {
          "name": "System Control",
          "equations": "T = (1 / f) \u22c5 (V / I)",
          "coding_directives": "Python",
          "python_code": "### Reasoning Process\n\nThe problem involves creating a high-fidelity physics/data-generation node for a system control unit. The given equation `T = (1 / f) \u22c5 (V / I)` represents the time constant of the system, where `T` is the time constant, `f` is the frequency, `V` is the voltage, and `I` is the current.\n\nTo create a high-fidelity node, we will:\n\n1. Define a function `calculate_time_constant` that takes `f`, `V`, and `I` as inputs and returns the time constant `T`.\n2. Implement input validation to ensure that the inputs are valid numbers.\n3. Use the `argparse` library to expose key parameters via the command line interface (CLI).\n4. Use the `logging` library to log important events and provide a verbosity flag.\n5. Write the results to an output file in a portable format (e.g., CSV).\n6. Create a minimal pytest suite to verify the correctness of the `calculate_time_constant` function.\n\n### Python Code\n\n```python\nimport argparse\nimport logging\nimport numpy as np\nimport csv\nimport pytest\n\n# Define the calculate_time_constant function\ndef calculate_time_constant(f, V, I):\n    \"\"\"\n    Calculate the time constant of the system.\n\n    Parameters:\n    f (float): Frequency\n    V (float): Voltage\n    I (float): Current\n\n    Returns:\n    float: Time constant\n    \"\"\"\n    if f == 0:\n        raise ValueError(\"Frequency cannot be zero\")\n    if I == 0:\n        raise ValueError(\"Current cannot be zero\")\n    return (1 / f) * (V / I)\n\n# Define the main function\ndef main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description=\"System Control Unit\")\n    parser.add_argument(\"-f\", type=float, help=\"Frequency\")\n    parser.add_argument(\"-V\", type=float, help=\"Voltage\")\n    parser.add_argument(\"-I\", type=float, help=\"Current\")\n    parser.add_argument(\"-v\", \"--verbosity\", type=int, help=\"Verbosity level\")\n    args = parser.parse_args()\n\n    # Set up logging\n    logging.basicConfig(level=logging.INFO if args.verbosity is None else args.verbosity)\n    logger = logging.getLogger(__name__)\n\n    # Calculate the time constant\n    try:\n        T = calculate_time_constant(args.f, args.V, args.I)\n        logger.info(f\"Time constant: {T}\")\n    except ValueError as e:\n        logger.error(e)\n\n    # Write the results to an output file\n    with open(\"outputs/time_constant.csv\", \"w\", newline=\"\") as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow([\"Time Constant\"])\n        writer.writerow([T])\n\n# Define a pytest suite\ndef test_calculate_time_constant():\n    assert np.isclose(calculate_time_constant(1.0, 10.0, 2.0), 5.0)\n\n# Define a coupling stub function\ndef send_data(T):\n    # This function would send the time constant to another node\n    pass\n\n# Define a receiving stub function\ndef receive_data():\n    # This function would receive data from another node\n    pass\n\nif __name__ == \"__main__\":\n    main()\n    # Run the pytest suite\n    pytest.main([__file__])\n```\n\n### Usage\n\nTo run the script, save it to a file (e.g., `system_control.py`) and execute it using Python:\n```bash\npython system_control.py -f 1.0 -V 10.0 -I 2.0\n```\nThis will calculate the time constant and write the result to an output file `outputs/time_constant.csv`. The verbosity level can be adjusted using the `-v` flag.\n\nTo run the pytest suite, use the following command:\n```bash\npytest system_control.py\n```",
          "coder_notes": "",
          "assumptions": [
            "Constant system load"
          ],
          "status": "Validated"
        }
      ],
      "linked_reqs": [
        "SR-04",
        "SR-05"
      ],
      "verification_plan": "Testing under controlled conditions",
      "maturity": "High",
      "tags": [
        "System Control",
        "Microcontroller"
      ]
    }
  },
  "edges": [
    [
      "SP-2",
      "P-2"
    ],
    [
      "P-2",
      "FU-2"
    ],
    [
      "FU-2",
      "CU-2"
    ],
    [
      "CU-2",
      "WT-2"
    ]
  ],
  "workflow_complete": false
}